Nous savons d√©sormais comment r√©cup√©rer un √©l√©ment HTML, le modifier et en cr√©er de nouveaux. Dans ce chapitre, nous apporterons une nouvelle dimension √† notre page gr√¢ce √† la programmation √©v√©nementielle. Concr√®tement, nous allons d√©couvrir comment r√©agir √† des √©v√©nements comme le clic ou l‚Äôutilisation du clavier, pour rendre notre projet interactif ! C‚Äôest parti !  üöÄ
D√©couvrez la programmation √©v√©nementielle

Jusqu‚Äô√† pr√©sent, notre code s‚Äôest toujours ex√©cut√© de mani√®re s√©quentielle : d‚Äôabord la premi√®re instruction, puis la seconde, et ainsi de suite jusqu‚Äô√† ce que toutes les instructions aient √©t√© ex√©cut√©es. Dans ce chapitre, nous allons aborder une nouvelle mani√®re d‚Äôenvisager la programmation, avec la programmation √©v√©nementielle.

Un √©v√©nement correspond √† une action sp√©cifique, comme par exemple le clic sur un bouton, ou la frappe d‚Äôun clavier. Ainsi, la programmation √©v√©nementielle consiste √† r√©agir √† ces √©v√©nements et ex√©cuter du code au moment o√π ces √©v√©nements se produisent.

Pour impl√©menter cela, nous devons d‚Äôabord dire √† JavaScript de les √©couter gr√¢ce √† un eventListener, litt√©ralement un ‚Äú√©couteur d‚Äô√©v√®nement‚Äù, en fran√ßais. Puis, nous devons lier l‚Äô√©v√©nement √† un bloc de code. C‚Äôest parti ! üöÄ
√âcoutez un √©v√©nement avec addEventListener

AddEventListener est une m√©thode fournie par JavaScript, qui peut √™tre appel√©e directement depuis les √©l√©ments HTML. Cette m√©thode prend deux param√®tres : 

    le nom de l‚Äô√©v√©nement, comme click, par exemple ;

    une fonction. 

La fonction peut s‚Äô√©crire de deux mani√®res diff√©rentes que nous allons voir :

    les fonctions classiques avec le mot-cl√© function ;

    les fonctions fl√©ch√©es. 

Utilisez addEventListener avec le mot-cl√© function

    Prenons un exemple tr√®s simple pour illustrer ceci. Cr√©ons un bouton dans un fichier HTML :

<button id="monBouton">Cliquez-moi !</button>

Dans le fichier JavaScript, nous allons r√©cup√©rer ce bouton et ajouter un √©couteur :

    let monBouton = document.getElementById("monBouton");

    monBouton.addEventListener("click", function () {

        console.log("Vous avez cliqu√© sur le bouton")

    });

D‚Äôabord nous r√©cup√©rons monBouton, jusqu‚Äôici, pas de souci. Ensuite, nous d√©finissons une fonction avec le mot-cl√© function.

Heuu‚Ä¶. Mais la fonction n‚Äôa pas de nom ? C‚Äôest normal‚Ä¶ ?

Eh oui ! Cette fonction n‚Äôa pas de nom, c‚Äôest ce qu‚Äôon appelle une fonction anonyme. Elle est cr√©√©e au moment o√π nous faisons notre addEventListener.

Si nous ex√©cutons ce code, le console.log ne s‚Äôaffichera pas, car nous avons simplement ajout√© un √©couteur d‚Äô√©v√©nement. Nous avons dit √† ce dernier : ‚ÄúLorsque l‚Äô√©v√©nement click se produit sur monBouton, alors tu vas ex√©cuter la fonction que je te donne‚Äù. Par cons√©quent, tant qu‚Äôon ne clique pas sur le bouton, il ne se passe rien. En revanche, le console.log appara√Ætra √† l‚Äôinstant o√π on cliquera dessus.

Ainsi, gardez bien en t√™te que, une fois que l‚ÄôaddEventListener est ex√©cut√©, la fonction pass√©e en param√®tre ne se lance pas imm√©diatement. Cette derni√®re sera lanc√©e :

    au moment o√π l'√©v√©nement qu‚Äôon √©coute (ici, un click sur monBouton) se produit ;

    autant de fois que l‚Äô√©v√©nement se produit (si on clique dix fois, nous verrons dix fois le message).

Utilisez addEventListener avec une fonction fl√©ch√©e

Dans l‚Äôexemple pr√©c√©dent, pour cr√©er une fonction nous avons utilis√© le mot-cl√© function. Cependant, pour corriger certains soucis notamment li√©s √† la manipulation des objets et √† la performance, JavaScript a introduit une autre notation : les fonctions fl√©ch√©es.

    Voyons un exemple d‚ÄôaddEventListener o√π le second argument, qui est la fonction qui sera ex√©cut√©e lorsque l‚Äô√©v√©nement se produit, est √©crit avec une fonction fl√©ch√©e :

monBouton.addEventListener("click", () => {

    console.log("Vous avez cliqu√© sur le bouton")

});

Dans le code ci-dessus :

    le mot function est remplac√© par des parenth√®ses vides ; 

    une fl√®che appara√Æt entre les parenth√®ses et les accolades (d‚Äôo√π le nom de fonction fl√©ch√©e !)

En d√©pit de ces modifications, le fonctionnement reste le m√™me. La fonction fl√©ch√©e sera appel√©e √† chaque fois que l‚Äôutilisateur va cliquer sur monBouton.

Les deux notations, fonction fl√©ch√©e et function, sont tr√®s utilis√©es. Cependant, pour la suite du cours, je vais privil√©gier la notation avec les fonctions fl√©ch√©es. 
R√©capitulons en vid√©o

Je vous propose de revoir ces d√©monstrations dans la vid√©o ci-dessous :
Pour aller plus loin : r√©cup√©rez les informations sur un √©v√©nement avec la variable ‚Äúevent‚Äù

Il arrive r√©guli√®rement que l‚Äôon souhaite avoir des informations sur l‚Äô√©v√©nement qui vient de se d√©rouler. Par exemple :

    Sur quel √©l√©ment l‚Äôutilisateur a-t-il cliqu√© ?

    Quelles √©taient les coordonn√©es de la souris ?

    Sur quelle touche du clavier l‚Äôutilisateur a-t-il appuy√© ?

    Un exemple classique est la gestion du clavier. Lorsque l‚Äôon appuie sur une touche, l‚Äô√©v√©nement appel√© keypress se d√©clenche. Nous pourrions d‚Äôailleurs l‚Äôutiliser dans notre application, par exemple, pour valider un mot lorsque l‚Äôon appuie sur la touche Entr√©e.

Nous pouvons √©couter cet √©v√©nement gr√¢ce √† addEventListener, mais comment savoir quelle touche a √©t√© press√©e ?

document.addEventListener('keypress', (event) => {

    console.log(event.key);

});

Entre les parenth√®ses est apparue une nouvelle variable appel√©e event. Cette variable est fournie directement par JavaScript. C‚Äôest un objet qui contient toutes les informations li√©es √† l‚Äô√©v√©nement. Ici, ce code affiche dans la console toutes les touches sur lesquelles nous pressons.

N‚Äôh√©sitez pas √† faire un console.log de event pour explorer un peu cette variable. JavaScript propose beaucoup d‚Äôinformations pour parer √† toutes les situations. Certaines d‚Äôentre elles sont particuli√®rement int√©ressantes : 

    event.target : renvoie l‚Äô√©l√©ment HTML qui a d√©clench√© l‚Äô√©v√©nement ;

    event.key : la touche appuy√©e quand l‚Äô√©v√©nement √©cout√© est li√© au clavier ;

    event.clientX et event.clientY : les coordonn√©es de la souris quand l‚Äô√©v√©nement √©cout√© est li√© √† la souris.

Je vous propose de revoir cette op√©ration dans la vid√©o ci-dessous :
√Ä vous de jouer !

Dans cet exercice, je vous propose de revenir sur plusieurs notions abord√©es tout au long de cette troisi√®me partie du cours, en modifiant notre projet. Pour le r√©aliser, je vous conseille de partir du r√©sultat que nous avons obtenu √† l‚Äôissue de l‚Äôexercice pr√©c√©dent.
√âtape 1 : nettoyez le projet

Votre premi√®re √©tape consiste √† supprimer les √©l√©ments qui seront modifi√©s dans notre projet :

    mettez en commentaire toutes les m√©thodes qui utilisent prompt ;

    mettez √† jour la fonction lancerJeu pour qu‚Äôelle ne fasse plus appel √† ces fonctions. 

Vous devez √©galement d√©sactiver temporairement le choix entre la liste des phrases et la liste des mots, de mani√®re √† utiliser syst√©matiquement la liste des mots  :

    mettez √† jour la fonction lancerJeu, et commentez ce qui concerne la variable listePhrases. 

Corrig√©

Vous pouvez v√©rifier votre travail en consultant la vid√©o ci-dessous :
√âtape 2 : g√©rez le clic sur le bouton ‚ÄúValider‚Äù

√Ä ce stade, le projet n‚Äôest plus fonctionnel, il n‚Äôest plus possible de jouer. Vous devez donc reconstruire ce que vous avez comment√© √† la premi√®re √©tape, en interagissant directement avec la page HTML.

Votre premi√®re √©tape est de pouvoir r√©agir au clic sur le bouton ‚ÄúEnvoyer‚Äù :

    Dans la fonction lancerJeu, r√©cup√©rez le bouton de validation et √©coutez l‚Äô√©v√©nement click en utilisant la m√©thode addEventListener.

    Testez que cela fonctionne avec un console.log(‚Äúj‚Äôai cliqu√© !‚Äù).

    R√©cup√©rez la balise inputEcriture et placez-la dans une variable. 

    Dans l‚ÄôaddEventListener, faites un console.log avec la valeur contenue dans cette balise.

Pour acc√©der √† la valeur contenue dans la balise inputEcriture, utilisez la propri√©t√© value. 

    Testez en √©crivant quelque chose dans le champ, et en v√©rifiant que la valeur appara√Æt bien lorsque vous cliquez sur Envoyer. 

Corrig√©

Vous pouvez v√©rifier votre travail en consultant la vid√©o ci-dessous :
√âtape 3 : affichez les mots que l‚Äôutilisateur doit recopier

√Ä ce stade, vous savez comment r√©cup√©rer le mot que l‚Äôutilisateur a √©crit, mais vous n‚Äôaffichez pas encore le mot qu‚Äôil devra recopier. Pour r√©aliser cette mise √† jour du code HTML :

    √† l‚Äôext√©rieur du addEventListener, cr√©ez une variable i qui servira de compteur. Dans l‚ÄôaddEventListener, ajoutez 1 √† i √† chaque fois que l‚Äôutilisateur clique sur le bouton Envoyer ; 

    ajoutez un console.log qui va afficher le mot num√©ro i du tableau listeMots ;

    cr√©ez une fonction afficherProposition, qui va prendre en param√®tre le mot √† afficher, et afficher ce mot dans la div zoneProposition ;  

    utilisez cette fonction pour afficher les mots √† proposer. 

Apr√®s ces op√©rations, vous devriez voir appara√Ætre les mots un par un apr√®s avoir r√©alis√© ces op√©rations. Cependant, vous remarquerez peut-√™tre que le mot ‚Äúundefined‚Äù s‚Äôaffiche lorsqu‚Äôil n‚Äôy a plus de mots disponibles dans le tableau. Pour r√©gler ce probl√®me :

    ajoutez un test dans l‚ÄôaddEventListener. Si le mot num√©ro i du tableau vaut undefined, √©crivez le message ‚ÄúLe jeu est fini‚Äù √† la place du mot, et d√©sactivez le bouton de validation. Pour d√©sactiver ce bouton, mettez la propri√©t√© disabled de ce bouton √† true ; 

    √† chaque fois que l‚Äôutilisateur clique sur Valider, videz le champ inputEcriture. 

Corrig√©

Vous pouvez v√©rifier votre travail en consultant la vid√©o ci-dessous :
√âtape 4 : g√©rez le score

Il nous reste une derni√®re √©tape : g√©rer le score de l‚Äôutilisateur.

    Dans l‚ÄôaddEventListener, comparez ce qu‚Äôa √©crit l‚Äôutilisateur et le mot propos√©. Si ces deux mots sont identiques, augmentez le score. 

    Dans tous les cas, mettez √† jour le score en appelant la fonction de mise √† jour du score avec les bons param√®tres. 

Corrig√©

Vous pouvez v√©rifier votre travail en consultant la vid√©o ci-dessous :

Je vous invite √©galement √† v√©rifier l‚Äôint√©gralit√© du projet en consultant ce corrig√© sur GitHub. Toutes mes f√©licitations pour votre travail ! ü•≥
En r√©sum√©

    La programmation √©v√©nementielle consiste √† √©crire du code qui r√©agit √† des √©v√©nements.

    Un √©v√©nement est un signal envoy√© par l‚Äô√©l√©ment HTML lorsque l‚Äôutilisateur effectue une action (clic, frappe au clavier‚Ä¶).

    Pour savoir quand un √©v√©nement est envoy√©, vous devez attacher un √©couteur √† l‚Äô√©l√©ment HTML.

    Pour g√©rer un √©v√©nement, vous devez l‚Äô√©couter en utilisant la m√©thode AddEventListener.

    Vous pouvez r√©cup√©rer des informations sur un √©v√©nement en utilisant la variable event.    La programmation √©v√©nementielle consiste √† √©crire du code qui r√©agit √† des √©v√©nements.

    Un √©v√©nement est un signal envoy√© par l‚Äô√©l√©ment HTML lorsque l‚Äôutilisateur effectue une action (clic, frappe au clavier‚Ä¶).

    Pour savoir quand un √©v√©nement est envoy√©, vous devez attacher un √©couteur √† l‚Äô√©l√©ment HTML.

    Pour g√©rer un √©v√©nement, vous devez l‚Äô√©couter en utilisant la m√©thode AddEventListener.

    Vous pouvez r√©cup√©rer des informations sur un √©v√©nement en utilisant la variable event.
