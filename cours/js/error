Nous avons vu ensemble comment vÃ©rifier la valeur dâ€™un champ. Mais comment rÃ©agir lorsque ce champ ne correspond pas Ã  ce quâ€™on attendait ? Cela peut Ãªtre le cas lorsque lâ€™utilisateur a oubliÃ© de renseigner le nom, ou lorsquâ€™il a mal Ã©crit son e-mailâ€¦

Câ€™est ce que nous dÃ©couvrirons ensemble dans ce dernier chapitre, Ã  travers deux mÃ©thodes :

    gÃ©rer les erreurs courantes grÃ¢ce Ã  if / else ;

    centraliser la gestion des erreurs grÃ¢ce aux exceptions try, catch et throw. 

Utilisez des if / else pour gÃ©rer les erreurs courantes

La maniÃ¨re la plus intuitive de gÃ©rer les erreurs est dâ€™utiliser les techniques que nous maÃ®trisons dÃ©jÃ  : les if / else.

    Pour illustrer cela, je vous propose dâ€™Ã©crire un code qui provoque une erreur, puis de voir ensemble comment gÃ©rer cette erreur.

let maVariable = document.getElementById("idInexistant")

maVariable.createElement("div")

Dans ce code, jâ€™ai dÃ©clarÃ© une premiÃ¨re variable dans laquelle jâ€™ai tentÃ© de rÃ©cupÃ©rer un Ã©lÃ©ment HTML qui nâ€™existe pas. Ensuite, jâ€™ai tentÃ© dâ€™utiliser la mÃ©thode createElement pour ajouter une div Ã  cet Ã©lÃ©ment.

Ce code nâ€™est pas valide. Nous pouvons dâ€™ailleurs le vÃ©rifier dans notre navigateur :
Capture d'Ã©cran. En haut Ã  gauche, un point d'exclamation. L'erreur s'affiche dans le navigateur.

Pour gÃ©rer ce type dâ€™erreur, nous pouvons tester la valeur de maVariable, et nous assurer quâ€™elle nâ€™est pas nulle :

let maVariable = document.getElementById("idInexistant")


if (maVariable === null) {

    console.log("L'Ã©lÃ©ment n'existe pas");

} else {

    maVariable.createElement("div")

    // suite du traitement...

}

Dans ce code, lâ€™instruction maVariable === null permet de tester si maVariable contient bien un Ã©lÃ©ment rÃ©cupÃ©rÃ© avec getElementById.

Ce code fonctionne trÃ¨s bien. Mais il est composÃ© de trois parties :

    les dÃ©clarations ;

    une portion pour gÃ©rer lâ€™erreur ;

    le rÃ©sultat.

OK trÃ¨s bienâ€¦ En quoi câ€™est un problÃ¨me ?

Le problÃ¨me câ€™est que nous avons, au milieu de notre code, une partie dont lâ€™unique but est de gÃ©rer lâ€™erreur. Vous avez peut-Ãªtre remarquÃ© mon commentaire â€œsuite du traitementâ€. Il est probable que nous ayons Ã  nouveau besoin de gÃ©rer des erreurs dans cette suiteâ€¦

En rÃ©alitÃ©, il est plutÃ´t conseillÃ© de placer la gestion de lâ€™erreur ailleurs, de maniÃ¨re Ã  avoir une structure en deux temps : dÃ©claration puis rÃ©sultat. ConcrÃ¨tement, on essaie dâ€™exÃ©cuter ce code, et en cas de problÃ¨me, on appelle un bloc de code ailleurs pour gÃ©rer lâ€™erreur.

Cela permet de distinguer dâ€™un cÃ´tÃ©, notre exÃ©cution â€œquand tout marche bienâ€, et de lâ€™autre la gestion de nos erreurs. Et vous savez quoi ? Câ€™est exactement ce que nous pourrons faire grÃ¢ce aux instructions try / catch. ğŸ˜ƒ
Centralisez la gestion des erreurs
Utilisez les instructions try / catch

Le bloc try / catch est composÃ© de deux parties : 

    lâ€™instruction try (essayer, en franÃ§ais) va essayer dâ€™exÃ©cuter du code ; 

    lâ€™instruction catch (attraper, en franÃ§ais) va attraper les Ã©ventuelles erreurs pour les gÃ©rer. 

    RÃ©Ã©crivons lâ€™exemple de la section prÃ©cÃ©dente avec try / catch :

try {

    let maVariable = document.getElementById("idInexistant")

    maVariable.createElement("div")

    // suite du traitement

} catch {

    console.log("Il y a eu une erreur dans le bloc try");

}

Dans cette nouvelle version, le code principal se passe dans la section try. En cas dâ€™erreur, le code sâ€™arrÃªtera immÃ©diatement, et le catch prendra le relais.

Ce qui est pratique, câ€™est que toute la gestion dâ€™erreur est centralisÃ©e dans la partie catch. En dâ€™autres termes, si nous utilisons 10 fois un createElement, inutile dâ€™Ã©crire 10 fois un if pour gÃ©rer les problÃ¨mes. Automatiquement, si lâ€™un dâ€™eux Ã©choue, câ€™est le mÃªme catch qui prend le relais !

Dâ€™ailleurs, souvenez-vous de lâ€™erreur dans le navigateur :

Capture d'Ã©cran : rappel du message d'erreur affichÃ© dans le navigateur.

Il Ã©tait Ã©crit â€œUncaughtâ€ (non-attrapÃ©e, en franÃ§ais). Lâ€™erreur n'avait pas Ã©tÃ© â€œattrapÃ©eâ€ par un catch, donc elle apparaissait telle quelle dans le navigateur.

Nous lâ€™avons vu, le try catch peut Ãªtre pratique. Ici lâ€™utilisation de createElement a Ã©chouÃ©. Ce qui sâ€™est passÃ© en rÃ©alitÃ©, câ€™est que nous avons tentÃ© dâ€™utiliser cette mÃ©thode, mais quand cela a Ã©chouÃ©, JavaScript a aussitÃ´t lancÃ© une exception pour prÃ©venir tout le monde : â€œAttention, une erreur sâ€™est produite, vous pouvez lâ€™attraperâ€.  
Utilisez lâ€™instruction throw

Try sert Ã  exÃ©cuter du code et catch Ã  attraper les erreurs. Cela marche bien avec des erreurs JavaScript qui sont conÃ§ues pour lancer des exceptions. Cependant, il arrive que nous voulions crÃ©er nos propres fonctions, qui lancent une exception en cas dâ€™Ã©chec.

Dans ce cas, la solution est dâ€™utiliser lâ€™instruction throw (lancer, en anglais). Cette derniÃ¨re nous permet de lancer nos propres exceptions, qui pourront alors Ãªtre attrapÃ©es par un catch.

    Dans notre projet, nous avons par exemple vÃ©rifiÃ© que le champ nom nâ€™Ã©tait pas vide. Utilisons maintenant try / catch et throw pour gÃ©rer ces erreurs :

function verifierChamp(champ) {

    // Si le champ est vide, on lance une exception

    if (champ.value === "") {

        throw new Error(`Le champ ${champ.id} est vide`)

    }

}

Dans ce code :

    jâ€™ai une fonction qui prend un champ en paramÃ¨tre ;

    si le champ est vide, alors je lance une exception que je crÃ©e grÃ¢ce Ã  new Error ;

    je passe Ã  cette erreur un paramÃ¨tre : le message dâ€™erreur. 

Ainsi, lorsque je vais attraper cette exception, je pourrai me servir de ce message pour afficher le texte que je veux ğŸ˜‰.

Le principe de try catch existe dans de nombreux langages de programmation. Câ€™est de ce principe quâ€™est nÃ©e lâ€™expression â€œlancer une exceptionâ€, mÃªme si en rÃ©alitÃ© ici, nous lanÃ§ons une â€œerreurâ€. Parfois, on parle Ã©galement de â€œlever une exceptionâ€.

    Voyons maintenant comment utiliser cette mÃ©thode pour tester un champ nom, un champ prenom et un champ surnom :

let form = document.querySelector("form")


form.addEventListener("submit", (event) => {

    try {

        event.preventDefault()


        let baliseNom = document.getElementById("nom")

        verifierChamp(baliseNom)


        let balisePrenom = document.getElementById("prenom")

        verifierChamp(balisePrenom)


        let baliseSurnom = document.getElementById("surnom")

        verifierChamp(baliseSurnom)


        // traitement du formulaire

        // ...

    } catch (error) {

        console.log("Une erreur est survenue : " + error.message)

    }

})

Dans ce code :

    jâ€™Ã©coute lâ€™Ã©vÃ©nement submit de mon formulaire ;

    je vÃ©rifie les champs un par un ;

    En cas de problÃ¨me, si un des champs est vide, le code va directement exÃ©cuter la partie catch.

Notez lâ€™utilisation de la propriÃ©tÃ© error.message pour afficher uniquement le message dâ€™erreur qui a Ã©tÃ© envoyÃ©.

Pfiouuuuâ€¦ Câ€™est quand mÃªme plus compliquÃ© que dâ€™utiliser des ifâ€¦ ğŸ˜…

Au premier abord, cela paraÃ®t effectivement plus compliquÃ©. ConsidÃ©rez try catch comme un outil mis Ã  disposition des programmeurs, au mÃªme titre que les fonctions, les objets, les tableaux, les bouclesâ€¦ Vous nâ€™Ãªtes pas obligÃ© de lâ€™utiliser, mais je vous garantis quâ€™une fois la technique maÃ®trisÃ©e, elle vous permettra dâ€™amÃ©liorer lâ€™organisation de votre code en centralisant la gestion des erreurs.
RÃ©capitulons en vidÃ©o

Retrouvez les dÃ©monstrations de ce chapitre dans la vidÃ©o ci-dessous :
Ã€ vous de jouer

Nous pouvons dÃ©sormais vÃ©rifier les champs dans notre projet. Cependant, lâ€™utilisateur ne reÃ§oit pour lâ€™instant aucune notification lorsqu'un problÃ¨me survient. Lâ€™objectif de cet exercice est dâ€™utiliser try catch pour prÃ©venir lâ€™utilisateur si un champ est mal renseignÃ©. 
Ã‰tape 1 : scindez la fonction lancerJeu

La fonction lancerJeu devient un petit peu trop grande, dâ€™autant plus si nous voulons en plus ajouter de la gestion dâ€™erreur. Votre premiÃ¨re Ã©tape consiste donc Ã  allÃ©ger la fonction, en dÃ©portant le traitement du formulaire : 

    CrÃ©ez une fonction gererFormulaire. Cette fonction va prendre en paramÃ¨tre le score Ã  envoyer, et sâ€™occuper de gÃ©rer le formulaire.

    Utilisez cette fonction dans lancerJeu. 

Ã‰tape 2 : affichez les erreurs

    Modifiez les fonctions validerNom et validerEmail : elles ne vont plus retourner true ou false, mais se contenter de lancer une exception en cas dâ€™erreur, avec un message expliquant le problÃ¨me.

Par exemple â€œLe nom est trop courtâ€ ou â€œLâ€™e-mail nâ€™est pas valideâ€.

    Modifiez la mÃ©thode gererFormulaire pour ajouter un try catch qui affiche â€œerreurâ€ dans la console. 

    CrÃ©ez une nouvelle fonction afficherMessageErreur qui prendra en paramÃ¨tre le message dâ€™erreur Ã  afficher. Pour afficher ce message, ajoutez en JavaScript un span Ã  la fin de la div .popup. 

Attention, si vous cliquez plusieurs fois sur le bouton, il ne faut pas que le message dâ€™erreur apparaisse plusieurs fois !

    Dans le bloc catch, appelez la fonction afficherMessageErreur pour afficher lâ€™erreur.

    Dans le bloc try, appelez cette fonction pour quâ€™elle efface le message dâ€™erreur. 

CorrigÃ©

Vous pouvez vÃ©rifier votre travail en consultant le corrigÃ© et la vidÃ©o ci-dessous : 
En rÃ©sumÃ©

    En tant que dÃ©veloppeur, veillez Ã  traiter toutes les erreurs qui pourraient survenir dans le code : 

        grÃ¢ce Ã  if / else pour les erreurs courantes ;

        en centralisation la gestion des erreurs grÃ¢ce aux exceptions try, catch et throw pour les situations plus complexes.

    Le bloc try catch fonctionne en deux parties :

        un bloc try qui essaie dâ€™exÃ©cuter une portion de code ;

        un bloc catch qui est lancÃ© si jamais un Ã©lÃ©ment du bloc try a lancÃ© une exception.

    Vous pouvez utiliser throw new Error(message) pour lancer vous-mÃªme vos exceptions.
